{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}

module SMCDEL.Examples.SimpleK where

import Data.HasCacBDD hiding (Bot,Top)
import Data.List ((\\))
import qualified Data.Map.Strict as M
import Data.Tagged (untag)

import SMCDEL.Explicit.K
import SMCDEL.Internal.TexDisplay
import SMCDEL.Language
import SMCDEL.Symbolic.K
import SMCDEL.Symbolic.S5 (boolBddOf)
import SMCDEL.Translations.K

-- * Example of product update

exampleModel :: KripkeModel
exampleModel = KrM $ M.fromList
  [ (1, (M.fromList [(P 0,True ),(P 1,True )], M.fromList [(alice,[1]), (bob,[1])] ) )
  , (2, (M.fromList [(P 0,False),(P 1,True )], M.fromList [(alice,[1]), (bob,[2])] ) ) ]

examplePointedModel :: PointedModel
examplePointedModel = (exampleModel,1)
$(addSvg 'examplePointedModel)

-- TODO: this already is a weird, non-reflexive model! maybe rather
-- start with something S5, then break it with priv. announcements?

{-$ The relations in this model can be described with these BDDs. -}

aliceBdd, bobBdd :: Bdd
[aliceBdd,bobBdd] = map (untag . flip SMCDEL.Symbolic.K.relBddOfIn exampleModel) [alice,bob]
-- TODO: addSvg

-- | Action model to privately tell alice that \(p_0\), while bob thinks nothing happens.
exampleGenActM :: ActionModel
exampleGenActM = ActM $ M.fromList
  [ (1, Act { pre = PrpF (P 0), post = M.empty, rel = M.fromList [(alice,[1]), (bob,[2])] } )
  , (2, Act { pre = Top       , post = M.empty, rel = M.fromList [(alice,[2]), (bob,[2])] } )
  ]

-- | Pointing `exampleGenActM` at actual event `1`.
examplePointedActM :: PointedActionModel
examplePointedActM = (exampleGenActM,1)
$(addSvg 'examplePointedActM)

-- | Result of updating `examplePointedModel` with `examplePointedActM`
exampleResult :: PointedModel
exampleResult = update examplePointedModel examplePointedActM
$(addSvg 'exampleResult)

-- * Example of transformation

exampleStart :: BelScene
exampleStart = (BlS [P 0] law obs, actual) where
  law    = boolBddOf Top
  obs    = M.fromList [ ("1", mvBdd $ boolBddOf Top), ("2", allsamebdd [P 0]) ]
  actual = [P 0]
$(addSvg 'exampleStart)

exampleEvent :: Event
exampleEvent = (Trf [P 1] addlaw M.empty eventObs, [P 1]) where
  addlaw = PrpF (P 1) `Impl` PrpF (P 0)
  eventObs = M.fromList [ ("1", allsamebdd [P 1]), ("2", cpBdd . boolBddOf $ Neg (PrpF $ P 1)) ]
$(addSvg 'exampleEvent)

-- | Result of updating `exampleStart` with `exampleEvent`.
exampleBlTresult :: BelScene
exampleBlTresult = exampleStart `update` exampleEvent
$(addSvg 'exampleBlTresult)

-- * Example of belief transformation with factual change

-- | Unused.
publicMakeFalseActM :: [Agent] -> Prp -> PointedActionModel
publicMakeFalseActM ags p =
  (ActM $ M.fromList [ (1::Int, Act myPre myPost myRel) ], 0) where
    myPre  = Top
    myPost = M.fromList [(p,Bot)]
    myRel  = M.fromList [(i,[1]) | i <- ags]

publicMakeFalseTrf :: [Agent] -> Prp -> Event
publicMakeFalseTrf agents p = (Trf [] Top changelaw eventobs, []) where
  changelaw = M.fromList [ (p,boolBddOf Bot) ]
  eventobs  = M.fromList [ (i,totalRelBdd) | i <- agents ]

-- | Publicly make `P 0` false.
myEvent :: Event
myEvent = publicMakeFalseTrf (agentsOf exampleStart) (P 0)
$(addSvg 'myEvent)

-- | Result of updating `exampleStart` with `myEvent`.
tResult :: BelScene
tResult = exampleStart `update` myEvent
$(addSvg 'tResult)

flipOverAndShowTo :: [Agent] -> Prp -> Agent -> Event
flipOverAndShowTo everyone p i = (Trf [q] eventlaw changelaw eventobs, [q]) where
  q         = freshp [p]
  eventlaw  = PrpF q `Equi` PrpF p
  changelaw = M.fromList [ (p, boolBddOf . Neg . PrpF $ p) ]
  eventobs  = M.fromList $ (i, allsamebdd [q])
                       : [ (j,totalRelBdd) | j <- everyone \\ [i] ]

myOtherEvent :: Event
myOtherEvent = flipOverAndShowTo ["1","2"] (P 0) "1"
$(addSvg 'myOtherEvent)

tResult2 :: BelScene
tResult2 = exampleStart `update` myOtherEvent
$(addSvg 'tResult2)

-- * Translations

{- | Result of `kripkeToBls examplePointedModel`.
(If voc is just P 0) We can see that Alice's relation only depends on the valuation at the destination point: In her BDD only the variable \(p'\) is checked.

Additionally, both agent BDDs do not care about \(p_1\) or \(p_1'\).
This is because in `kripkeToBls` we use `restrictLaw`.
This ensures our relation bdds do not become unnecessarily large.
The BDDs generated by `relBddOfIn` include checks that both parts of the related pair are actually states of the structure.
However, we do not need to repeat this information in the BDDs for each agent, because the state law already contains it.
-}
exampleBelScn :: BelScene
exampleBelScn = kripkeToBls examplePointedModel
$(addSvg 'exampleBelScn)
